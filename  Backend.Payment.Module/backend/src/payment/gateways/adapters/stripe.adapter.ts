import { Injectable, Logger } from '@nestjs/common';
import { IPaymentGateway } from '../../interfaces/payment-gateway.interface';
import { ProcessPaymentDto } from '../../dto/process-payment.dto';
import { PaymentResponseDto } from '../../dto/payment-response.dto';
import { RefundPaymentDto } from '../../dto/refund-payment.dto';
import { CreateRecurringPaymentDto } from '../../dto/create-recurring-payment.dto';
import { RecurringPaymentDetailsDto } from '../../dto/recurring-payment-details.dto';
import { CancelRecurringPaymentDto } from '../../dto/cancel-recurring-payment.dto';
import { WebhookEventDto } from '../../dto/webhook-event.dto';
import { PaymentStatus, GatewayIdentifier } from '../../constants/payment.constants';
import {
  PaymentGatewayIntegrationException,
  InvalidPaymentDetailsException,
  SubscriptionManagementErrorException,
  RefundProcessingException,
} from '../../exceptions/payment.exceptions';
import { ConfigService } from '@nestjs/config';
// Assume StripeClient is provided by IntegrationModule
import { StripeClient } from '../../../integration/gateways/clients/stripe/stripe.client'; // Simulated Import
import { PaymentConfig } from '../../config/payment.config';

@Injectable()
export class StripeAdapter implements IPaymentGateway {
  private readonly logger = new Logger(StripeAdapter.name);
  private readonly webhookSecret: string;

  constructor(
    private readonly stripeClient: StripeClient, // Injected from IntegrationModule
    private readonly configService: ConfigService<PaymentConfig>, // From CoreModule
  ) {
    // Webhook secret ideally fetched securely via CoreModule.ConfigService
    this.webhookSecret = this.configService.get<string>('payment.stripeWebhookSecret');
    if (!this.webhookSecret) {
       this.logger.error('Stripe webhook secret is not configured.');
       // Depending on application startup requirements, this could be a fatal error
    }
  }

  async processPayment(paymentDetails: ProcessPaymentDto): Promise<PaymentResponseDto> {
    try {
      // Translate internal DTO to Stripe API format
      const stripeChargeParams = {
        amount: Math.round(paymentDetails.amount * 100), // Stripe uses cents
        currency: paymentDetails.currency.toLowerCase(),
        source: paymentDetails.paymentMethodToken, // Tokenized payment method ID or card ID
        description: paymentDetails.description,
        metadata: {
          orderId: paymentDetails.orderId,
          merchantId: paymentDetails.merchantId,
        },
        // Add other necessary Stripe parameters like customer, capture method, etc.
        capture: true, // Assuming immediate capture
      };

      this.logger.debug(`Calling Stripe charge.create with params: ${JSON.stringify(stripeChargeParams)}`);
      const charge = await this.stripeClient.charges.create(stripeChargeParams);
      this.logger.log(`Stripe charge successful: ${charge.id}`);

      // Translate Stripe response to internal DTO
      return {
        transactionId: '', // This should be generated internally by PaymentService before calling the adapter
        gatewayTransactionId: charge.id,
        status: charge.status === 'succeeded' ? PaymentStatus.SUCCESSFUL : PaymentStatus.FAILED, // Map Stripe status to internal enum
        message: charge.failure_message || 'Payment successful',
        gatewayResponse: charge, // Include non-sensitive parts of the response
      };
    } catch (error) {
      this.logger.error(`Stripe payment processing failed: ${error.message}`, error.stack);
      // Translate specific Stripe errors to internal exceptions
      if (error.type === 'StripeCardError') {
        throw new InvalidPaymentDetailsException(error.message, error);
      }
      throw new PaymentGatewayIntegrationException(GatewayIdentifier.STRIPE, `Error processing payment: ${error.message}`, error.raw || error, error);
    }
  }

  async refundPayment(refundDetails: RefundPaymentDto): Promise<PaymentResponseDto> {
    try {
      const stripeRefundParams = {
        charge: refundDetails.gatewayTransactionId,
        amount: refundDetails.amount ? Math.round(refundDetails.amount * 100) : undefined, // Amount in cents, optional for full refund
        reason: refundDetails.reason,
        metadata: {
           merchantId: refundDetails.merchantId,
        }
      };

      this.logger.debug(`Calling Stripe refunds.create with params: ${JSON.stringify(stripeRefundParams)}`);
      const refund = await this.stripeClient.refunds.create(stripeRefundParams);
      this.logger.log(`Stripe refund initiated/successful: ${refund.id}`);

      // Translate Stripe response to internal DTO
       return {
           transactionId: '', // Internal ID will be generated by PaymentService
           gatewayTransactionId: refund.id, // Stripe Refund ID
           status: refund.status === 'succeeded' || refund.status === 'pending' ? PaymentStatus.PENDING : PaymentStatus.FAILED, // Map Stripe refund status
           message: refund.failure_reason || 'Refund processed',
           gatewayResponse: refund, // Include non-sensitive parts
       };

    } catch (error) {
      this.logger.error(`Stripe refund failed: ${error.message}`, error.stack);
       throw new RefundProcessingException(`Error processing Stripe refund: ${error.message}`, error.raw || error);
    }
  }

  async createRecurringPayment(subscriptionDetails: CreateRecurringPaymentDto): Promise<RecurringPaymentDetailsDto> {
    try {
        const stripeSubscriptionParams = {
            customer: 'cus_XYZ', // Placeholder: Needs logic to find/create Stripe customer
            items: [{ price: subscriptionDetails.planId }], // Using Stripe Price ID as planId
            collection_method: 'charge_automatically',
            metadata: {
                 merchantId: subscriptionDetails.merchantId,
                 customerId: subscriptionDetails.customerId,
                 internalPlanId: subscriptionDetails.planId // For internal reference
            }
        };

        this.logger.debug(`Calling Stripe subscriptions.create with params: ${JSON.stringify(stripeSubscriptionParams)}`);
        const subscription = await this.stripeClient.subscriptions.create(stripeSubscriptionParams);
        this.logger.log(`Stripe subscription created: ${subscription.id}`);

        return {
            gatewaySubscriptionId: subscription.id,
            status: subscription.status,
            currentPeriodStart: subscription.current_period_start ? new Date(subscription.current_period_start * 1000) : undefined,
            currentPeriodEnd: subscription.current_period_end ? new Date(subscription.current_period_end * 1000) : undefined,
            nextBillingDate: subscription.current_period_end ? new Date(subscription.current_period_end * 1000) : undefined,
            planDetails: subscription.items.data[0]?.price || {},
        };
    } catch (error) {
        this.logger.error(`Stripe recurring payment setup failed: ${error.message}`, error.stack);
        throw new SubscriptionManagementErrorException(GatewayIdentifier.STRIPE, `Error setting up recurring payment: ${error.message}`, error.raw || error, error);
    }
  }

  async getRecurringPaymentDetails(gatewaySubscriptionId: string): Promise<RecurringPaymentDetailsDto> {
    try {
        this.logger.debug(`Calling Stripe subscriptions.retrieve for ID: ${gatewaySubscriptionId}`);
        const subscription = await this.stripeClient.subscriptions.retrieve(gatewaySubscriptionId);
        this.logger.log(`Stripe subscription retrieved: ${subscription.id}`);

        return {
            gatewaySubscriptionId: subscription.id,
            status: subscription.status,
            currentPeriodStart: subscription.current_period_start ? new Date(subscription.current_period_start * 1000) : undefined,
            currentPeriodEnd: subscription.current_period_end ? new Date(subscription.current_period_end * 1000) : undefined,
            nextBillingDate: subscription.current_period_end ? new Date(subscription.current_period_end * 1000) : undefined,
            planDetails: subscription.items.data[0]?.price || {},
        };
    } catch (error) {
        this.logger.error(`Stripe recurring payment details retrieval failed for ID ${gatewaySubscriptionId}: ${error.message}`, error.stack);
         throw new SubscriptionManagementErrorException(GatewayIdentifier.STRIPE, `Error retrieving recurring payment details: ${error.message}`, error.raw || error, error);
    }
  }

  async cancelRecurringPayment(cancelDetails: CancelRecurringPaymentDto): Promise<void> {
    try {
        this.logger.debug(`Calling Stripe subscriptions.del for ID: ${cancelDetails.gatewaySubscriptionId}`);
        await this.stripeClient.subscriptions.del(cancelDetails.gatewaySubscriptionId);
        this.logger.log(`Stripe subscription canceled: ${cancelDetails.gatewaySubscriptionId}`);
    } catch (error) {
        this.logger.error(`Stripe recurring payment cancellation failed for ID ${cancelDetails.gatewaySubscriptionId}: ${error.message}`, error.stack);
        throw new SubscriptionManagementErrorException(GatewayIdentifier.STRIPE, `Error canceling recurring payment: ${error.message}`, error.raw || error, error);
    }
  }

  verifyWebhookSignature(payload: string | Buffer, signature: string, secret: string): boolean {
    try {
        this.logger.debug('Verifying Stripe webhook signature...');
        // The Stripe client's constructEvent method also parses the event.
        // For pure signature verification, this is the standard way.
        // If the payload is already parsed (e.g., req.body), Stripe SDK might need raw buffer.
        this.stripeClient.webhooks.constructEvent(
            payload, // Should be the raw request body
            signature,
            secret
        );
        this.logger.debug('Stripe webhook signature verified successfully.');
        return true;
    } catch (err) {
        this.logger.error(`Stripe webhook signature verification failed: ${err.message}`);
        return false;
    }
  }

  parseWebhookEvent(rawPayload: any): WebhookEventDto {
    // Assuming `rawPayload` is the already verified and parsed event object from `constructEvent`
    // If `rawPayload` is the raw string/buffer, then `constructEvent` should be called here again or
    // the result of `constructEvent` from `verifyWebhookSignature` should be passed.
    // For this example, let's assume it's the parsed event object as Stripe's `constructEvent` does both.
    const event = rawPayload as any; // This type needs to be Stripe.Event

    this.logger.debug(`Parsing Stripe webhook event type: ${event.type}`);

    return {
        gateway: GatewayIdentifier.STRIPE,
        eventType: event.type,
        payload: event.data.object,
        receivedAt: new Date(event.created * 1000),
    };
  }
}